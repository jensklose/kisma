<?php
/**
 * @file
 * Provides a base for Kisma components and objects
 *
 * Kisma(tm) : PHP Nanoframework (http://github.com/lucifurious/kisma/)
 * Copyright 2009-2011, Jerry Ablan, All Rights Reserved
 *
 * @copyright Copyright (c) 2009-2011 Jerry Ablan
 * @license http://github.com/lucifurious/kisma/blob/master/LICENSE
 *
 * @author Jerry Ablan <kisma@pogostick.com>
 * @category Silex
 * @package kisma.components
 * @since 1.0.0
 *
 * @ingroup silex
 */
namespace Kisma\Components;

use Kisma\Event;
use Kisma\Utility as Utility;
use Kisma\Utility\Property;

/**
 * Seed
 * A nugget of goodness that grows into something wonderful
 *
 * @property array $options
 * @property int $index
 * @property int $count
 * @property boolean $skipNext
 * @property-read string $objectId A unique object ID generated by spl_object_hash
 * @property bool $propertiesRequired If true, trying to set an undefined property will result in and UndefinedPropertyException
 */
abstract class Seed implements \Kisma\IKisma, \Kisma\IConfigurable, \Countable, \Iterator
{
	//*************************************************************************
	//* Private Members
	//*************************************************************************

	/**
	 * @var array This object's options
	 */
	protected $_options = array();
	/**
	 * @var integer Iteration index
	 */
	protected $_index = 0;
	/**
	 * @var integer Holds the number of settings we have
	 */
	protected $_count = 0;
	/**
	 * @var boolean Used when un-setting values during iteration to ensure we do not skip the next element
	 */
	protected $_skipNext = false;
	/**
	 * @var string My unique object ID
	 */
	protected $_objectId = null;
	/**
	 * @var bool If true, setting an undefined property throws an exception
	 */
	protected $_propertiesRequired = false;
	/**
	 * @var array Object metrics
	 */
	protected static $_metrics = array();

	//*************************************************************************
	//* Default/Magic Methods
	//*************************************************************************

	/**
	 * The base component constructor
	 *
	 * @param object|array $options
	 *
	 * @return \Kisma\Components\Seed
	 */
	public function __construct( $options = array() )
	{
		//	Metrics
		$_startTime = microtime( true );

		//	Configure our options/properties
		$this->setOptions( $options, true );

		//	Initialize event system
		Utility\Events::subscribe( $this );

		//	Fire the initialize event
		$this->dispatch( Event\ComponentEvent::AfterConstruct );

		//	Store metrics
		self::$_metrics[__METHOD__] = microtime( true ) - $_startTime;
	}

	/**
	 * Destructor stub
	 */
	public function __destruct()
	{
		//	Fire the initialize event
		$this->dispatch( Event\ComponentEvent::BeforeDestruct );
	}

	/**
	 * @param string	 $name
	 * @param mixed|null $value
	 *
	 * @return mixed
	 */
	public function setOption( $name, $value = null )
	{
		Property::set( $this, $name, $value, $this->_propertiesRequired );
		return $this;
	}

	/**
	 * @return array
	 */
	public function &getOptions()
	{
		return $this->_options;
	}

	/**
	 * @param string						   $eventName
	 * @param \Kisma\Event\KismaEvent|null	 $event
	 */
	public function dispatch( $eventName, $event = null )
	{
		\Kisma\K::app( 'dispatcher' )->dispatch( $eventName, $event ? : new \Kisma\Event\ComponentEvent( $this ) );
	}

	/**
	 * Loads an array into properties if they exist.
	 *
	 * @param object|array $options
	 * @param bool		 $mergeOptions If false, this object's options will be cleared first
	 *
	 * @return void
	 */
	public function setOptions( $options = array(), $mergeOptions = true )
	{
		//	Create our hash...
		$this->_objectId = spl_object_hash( $this );

		//	Catch null input, non-traversable, or empty options
		if ( empty( $options ) || ( !is_array( $options ) && !( $options instanceof \Traversable ) && !( $options instanceof \stdClass ) ) )
		{
			$options = array();
		}

		//	Set our own options and work from there
		if ( true !== $mergeOptions || !is_array( $options ) )
		{
			//	Overwrite the options...
			$this->_options = (array)$options;
		}
		else
		{
			//	Merge the options...
			$this->_options = array_merge( $this->_options, (array)$options );
		}

		//	Loop through, set...
		foreach ( $this->_options as $_key => $_value )
		{
			$this->setOption( $_key, $_value );
		}

		$this->_count = count( $this->_options );

		return $this;
	}

	//*************************************************************************
	//* Interface Methods
	//*************************************************************************

	/**
	 * Required by Countable interface
	 *
	 * @return int
	 */
	public function count()
	{
		return $this->_count;
	}

	/**
	 * Required by Iterator interface
	 *
	 * @return mixed
	 */
	public function current()
	{
		$this->_skipNext = false;
		return current( $this->_options );
	}

	/**
	 * Required by Iterator interface
	 *
	 * @return mixed
	 */
	public function key()
	{
		return key( $this->_options );
	}

	/**
	 * Required by Iterator interface
	 */
	public function next()
	{
		if ( $this->_skipNext )
		{
			$this->_skipNext = false;
			return;
		}

		next( $this->_options );

		$this->_index++;
	}

	/**
	 * Required by Iterator interface
	 */
	public function rewind()
	{
		$this->_skipNext = false;
		reset( $this->_options );
		$this->_index = 0;
	}

	/**
	 * Required by Iterator interface
	 *
	 * @return boolean
	 */
	public function valid()
	{
		return ( $this->_index < $this->_count );
	}

	//*************************************************************************
	//* Event Handlers
	//*************************************************************************

	/**
	 * @param \Kisma\Event\KismaEvent $event
	 *
	 * @return bool
	 */
	public function onAfterConstruct( \Kisma\Event\KismaEvent $event )
	{
		return true;
	}

	/**
	 * @param \Kisma\Event\KismaEvent $event
	 *
	 * @return bool
	 */
	public function onBeforeDestruct( \Kisma\Event\KismaEvent $event )
	{
		return true;
	}

	//*************************************************************************
	//* Private Methods
	//*************************************************************************

	/**
	 * Serializer
	 * Dynamically generates the object from the properties of the current object.
	 * Properties must have a "getter" to be included.
	 *
	 * @return \stdClass
	 */
	public function toObject()
	{
		$_obj = new \stdClass();

		$_me = new \ReflectionObject( $this );
		$_properties = $_me->getProperties( \ReflectionProperty::IS_PUBLIC );

		if ( !empty( $_properties ) )
		{
			$_myClass = __CLASS__;

			foreach ( $_properties as $_property )
			{
				//	Only want our own properties, not the base class
				if ( isset( $_property->class ) )
				{
					$_class = new \ReflectionClass( $_property->class );

					if ( !empty( $_class ) && !$_class->isSubclassOf( $_myClass ) )
					{
						continue;
					}

					unset( $_class );
				}

				try
				{
					$_propertyName = ltrim( $_property->name, '_' );

					if ( !Property::checkProperty( $this, $_propertyName ) )
					{
						//	No getter, skipping you!
						continue;
					}

					//	Set the property value
					Property::set( $this, $_propertyName );
				}
				catch ( \Exception $_ex )
				{
					//	Just ignore, not a valid property if we can't read it with a getter
				}
			}
		}

		//	Return our object
		return $_obj;
	}

	//*************************************************************************
	//* Properties
	//*************************************************************************

	/**
	 * @param int $count
	 *
	 * @return \Kisma\Components\Seed
	 */
	public function setCount( $count )
	{
		$this->_count = $count;
		return $this;
	}

	/**
	 * @return int
	 */
	public function getCount()
	{
		return $this->_count;
	}

	/**
	 * @param int $index
	 *
	 * @return \Kisma\Components\Seed
	 */
	public function setIndex( $index )
	{
		$this->_index = $index;
		return $this;
	}

	/**
	 * @return int
	 */
	public function getIndex()
	{
		return $this->_index;
	}

	/**
	 * @return string
	 */
	public function getObjectId()
	{
		return $this->_objectId;
	}

	/**
	 * @param boolean $propertiesRequired
	 *
	 * @return \Kisma\Components\Seed
	 */
	public function setPropertiesRequired( $propertiesRequired )
	{
		$this->_propertiesRequired = $propertiesRequired;
		return $this;
	}

	/**
	 * @return boolean
	 */
	public function getPropertiesRequired()
	{
		return $this->_propertiesRequired;
	}

	/**
	 * @param boolean $skipNext
	 *
	 * @return \Kisma\Components\Seed
	 */
	public function setSkipNext( $skipNext )
	{
		$this->_skipNext = $skipNext;
		return $this;
	}

	/**
	 * @return boolean
	 */
	public function getSkipNext()
	{
		return $this->_skipNext;
	}

	/**
	 * @return array
	 */
	public static function getMetrics()
	{
		return self::$_metrics;
	}

}